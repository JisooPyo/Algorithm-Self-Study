# Conclusion

이전 챕터에서, 재귀의 개념과 원리에 대해 살펴보았다.

상기하기 위해, 여기에 재귀 문제를 푸는 일반적인 workflow를 제공한다.

1. `재귀 함수`를 정의하라.
2. `recurrence relation`과 `base case`에 대해 적어라.
3. 만약 존재한다면, `반복 계산` 문제를 제거하기 위하여 `memoization`을 사용하라.
4. 가능할 때마다, 공간 복잡도를 최적화하기 위해 함수를 꼬리 재귀로 구현하라.

이 챕터에서는, 재귀 알고리즘에 대해 결론내고 몇 가지 문제를 어떻게 재귀로 푸는지에 대한 팁을 제공한다.

<br>

## Conclusion - Recursion 1

이제, 재귀는 정말 많은 문제를 우아하고 효율적인 방법으로 풀 수 있게 해주는 기술이라는 것을 납득했을 것이다. 
하지만 아직도, silver bullet은 아니다. 모든 문제를 재귀로는 풀 수 없다. 시간과 공간의 제약이 있기 때문이다.
그리고 재귀는 stack overflow와 같은 바라지 않은 부작용이 같이 올 수 있다.

이 챕터에서는 실제 세계에서 문제를 풀기 위해 어떻게 재귀를 더 잘 적용하는지에 대한 몇 가지 팁을 공유하고자 한다.

```text
확신이 서지 않으면, recurrence relationship을 적어라.
```

가끔, 언뜻 보기에 문제를 푸는데 재귀 알고리즘을 적용할 수 있는지가 분명하지 않을 때가 있다.
그러나, 재귀에서 반복하는 특성이 우리와 친숙한 수학과 매우 비슷하기 때문에, 
수학 공식을 사용하여 일부 관계를 추론하는 것은 항상 도움이 된다.
이는 가끔 아이디어를 명확하게 하고, 숨겨진 `recurrence relationship`을 발견할 수 있게 할 것이다.
이 챕터에서, **Unique Binary Search Trees 2**라는 재미있는 문제를 발견할 수 있을텐데,
이 문제는 수학식의 도움을 받아 재귀를 이용하여 해결할 수 있다.

```text
가능하다면 memoization을 적용하라.
```

처음 재귀 알고리즘을 해결할 때, 가장 순진한 전략부터 시작할 수 있다.
가끔, 재귀로 인해 `반복 계산`이 발생할 수 있는 상황이 있을 수도 있다.(ex. 피보나치 수열)
이 경우, 나중에 재사용하기 위해 중간 결과를 캐시에 저장해두는 memoization 테크닉을 적용할 수 있다.
Memoization은 비용이 많이 드는 반복 계산의 문제를 피할 수 있기 때문에
약간의 공간 복잡도와 교환해 시간 복잡도를 아주 크게 향상시켜줄 수 있다.

```text
stack overflow가 일어난다면, 꼬리 재귀가 도울 수 있을 것이다.
```

재귀를 이용하여 알고리즘을 구현하는 방법은 몇 가지가 있다.
꼬리 재귀는 구현할 수 있는 재귀의 특정한 형태이다.
memoization 테크닉과는 다르게, 꼬리 재귀는 재귀에서 일어나는 스택 오버헤드를 제거함으로써,
알고리즘의 공간 복잡도를 최적화한다.
더욱 중요한 것은 꼬리 재귀로써 재귀에서 종종 발생하는 `stack overflow`의 문제를 피할 수 있다는 것이다.
꼬리 재귀의 또 다른 장점은 꼬리 재귀가 아닌 것과 비교하여 더 읽고 이해하기 쉽다는 것이다.
비꼬리 재귀와는 다르게 꼬리 재귀에서는 post-call dependency가 없기 때문이다.
(즉, 함수에서 함수 호출이 가장 마지막 action이라는 뜻이다.)
그러므로, 가능하다면, 꼬리 재귀를 적용시킬 수 있도록 노력해야 할 것이다.