## Principle of Recursion

이 챕터에서는,

* 재귀의 기본적인 개념을 설명한다.
* 특정 문제들을 풀기 위해 재귀를 적용하는 방법에 대해 설명한다.
* 재귀를 연습하기 위해 몇 가지 연습문제를 제공한다.

---

```text
재귀는 서브루틴으로써 스스로 호출하는 함수를 사용하여 문제를 해결하는 접근이다.
```

스스로 호출하는 함수를 어떻게 구현할 수 있는지 궁금할 것이다.
트릭은 재귀 함수가 스스로 호출할 때마다 주어진 문제를 하위 문제로 줄이는 것이다.
재귀 호출은 더 이상의 재귀 없이 하위 문제가 해결될 수 있는 점에 도달할 때까지 계속된다.

재귀 함수는 무한 루프에 빠지지 않게 하기 위하여 다음 특성을 가져야 한다.

1. 간단한 `기본 케이스`(또는 기본 케이스들) - 재귀를 사용하지 않고 답을 내놓는 종료 시나리오.
2. 규칙 세트 또는 재귀 관계 - 모든 다른 케이스를 기본 케이스로 향하게 줄인다.

함수에서 자기자신을 호출할 수 있는 여러 장소가 있을 수 있다는 점에 유의하라.

<br>

### Example

간단한 프로그래밍 문제로 시작해보자.

```text
주어진 문자열을 역순으로 출력하라.
```

이 문제는 반복적으로 쉽게 해결할 수 있다. 즉, 문자열을 끝에서 시작하여 순환하는 방식이다.
그러나 재귀적으로 어떻게 해결할까?

먼저, printReverse(str[0...n-1])라는 원하는 함수를 정의할 수 있다.
여기서 str[0]는 문자열의 첫 번째 문자를 나타낸다.
그런 다음 주어진 작업을 두 단계로 수행할 수 있다:

1. printReverse(str[1...n-1]): str[1...n-1] 부분 문자열을 역순으로 출력한다.
2. print(str[0]): 문자열의 첫 번째 문자를 출력한다.

첫 번째 단계에서 함수 자체를 호출하는 것에 주목하라.
이것이 함수를 재귀적으로 만드는 정의이다.

<br>

---

## Recursion Function

문제에서 재귀적으로 푸는 해결방법이 존재한다면 그것을 구현하기 위해 아래의 가이드라인을 따를 수 있다.

예를 들어, 문제를 함수 `F(X)`로 정의해서 구현한다. 여기서 `X`는 함수의 input이자 문제의 범위를 정의한다.

이제 함수 F(x)에서, 다음을 진행한다.

1. 문제를 더 작은 범위로 쪼갠다.(x0 ∈ X, x1 ∈ X, ... , xn ∈ X와 같이)
2. X의 하위 문제를 풀기 위해 재귀적으로 함수 F(x0), F(x1), ..., F(xn)를 호출한다.
3. 마지막으로 X에 해당하는 문제를 해결하기 위해 재귀 함수 호출로부터의 결과를 처리한다.

<br>

---

### Example

위의 가이드라인을 보여주기 위해, 어떻게 문제를 재귀적으로 푸는지에 대한 예제를 또 하나 살펴보겠다.

```text
주어진 Linked List에서, 모든 두 개의 인접한 노드들을 스왑하고 head 노드를 반환하라.

e.g. list 1 -> 2 -> 3 -> 4에서, list 2 -> 1 -> 4 -> 3의 head를 반환하라. 
```

구현할 함수를 `swap(head)`로 정의하자. 여기서 input 매개변수 `head`는 linked list의 head를 의미한다.
함수는 모든 인접한 노드들이 스왑된 새로운 linked list의 `head`를 반환해야 한다.

위에 언급했던 가이드라인을 따라서 다음과 같이 함수를 구현할 수 있다.

1. 첫번째로, list의 첫번째 두 노드를 스왑한다.(즉, `head`와 `head.next`)
2. 다음으로, list의 나머지를 스왑하기 위하여 swap(head.next.next)로 자기자신의 함수를 호출한다.
3. 마지막으로 새로운 linked list를 만들기 위해 step1에서 스왑된 두 노드에 step2에서의 sub-list의 반환된 head를 붙인다.

