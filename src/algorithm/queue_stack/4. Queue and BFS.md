## Queue and BFS

선행: 트리 Level-order 순회

`Breadth-first search`(BFS) 는 트리나 그래프같은 자료 구조를 순회하거나 탐색하는 한 알고리즘이다.

앞에서 얘기했다시피, `tree`에서 level-order 순회를 하기 위하여 BFS를 사용할 수 있다.

또한, `그래프`를 순회할 때에도 BFS를 사용할 수 있다.
예를 들어, 시작 노드에서 타겟 노드까지 길을 찾기 위해(특히 가장 짧은 경로) BFS를 사용할 수 있다.

BFS를 사용하여 더 추상적인 시나리오에서 모든 가능한 상태를 탐색할 수 있다.
이 경우 상태를 그래프의 노드로, 경로를 그래프의 엣지로 간주할 수 있다.

이 챕터에서는 어떻게 BFS가 작동하는지 간단하게 복습하고, 어떻게 queue가 BFS 알고리즘을 구현하는 것을 돕는지에 대해 좀 더 포커싱할 것이다.
또한 BFS를 고안하고 구현하는 연습문제를 제공할 것이다.

<br>

너비 우선 탐색(BFS)의 흔한 사용법은 root 노드에서 타겟 노드까지 가장 짧은 경로를 찾는 것이다.
이 article에서는 어떻게 큐가 BFS 알고리즘에 적용되는지 step별로 설명하는 예제를 제공한다.

<br>

---

### An Example

여기 루트 노드 A 와 타겟 노드 G 사이에 가장 짧은 경로를 찾기 위해 어떻게 BFS가 사용되는지 보여주는 예제가 있다.

[예제 영상 링크](https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/1376/)

<br>

---

### Insights

위 예제 영상을 보고 나서, 다음 질문에 답해보자.

<br>

#### 1. 노드들의 처리 순서는 어떻게 되는가?

첫번째 라운드에서, 루트 노드를 처리한다.
두번째 라운드에서, 루트 노드 옆 노드들을 처리한다.
세번째 라운드에서, 루트 노드에서 두 스텝 떨어져 있는 노드를 처리한다.
이 방식으로 계속된다.

트리의 level-order 순회와 비슷하게, 루트 노드와 더 가까운 노드가 먼저 순회된다.

만약 `k번째` 라운드에서, 큐에 노드 `X`가 추가된다면, 루트 노드와 `X` 사이에 가장 짧은 경로의 길이는 정확히 `k`이다.
이것은 타겟 노드를 찾는 동시에 이미 가장 짧은 경로를 알아낸다는 것이다.

#### 2. 큐의 enqueue와 dequeue의 순서는 어떻게 되는가?

처음에 루트 노드를 큐에 삽입한다.
그리고 나서 각 라운드에서, 이미 큐에 있는 노드를 하나씩 처리하고 그들의 이웃 노드를 큐에 삽입한다.
새롭게 추가된 노드들이 바로 체크되는 것이 아니라 다음 라운드에서 처리된다는 점에 주목할 필요가 있다.
노드들의 처리되는 순서는 큐에 추가된 순서와 정확히 동일하며, 이는 First-in-First-out(FIFO) 방식이다.
이것이 BFS에서 큐를 사용하는 이유이다.