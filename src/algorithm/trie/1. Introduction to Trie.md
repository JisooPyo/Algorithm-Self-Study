# Introduction

`접두 트리`로도 불리는 `트라이`는 `Nary tree`의 특별한 형태이다.

이 카드에서는 트라이의 구현에 대해 더 자세히 알아보고
이 자료 구조를 사용하여 문제를 해결하는 방법에 대해 얘기할 것이다.

이 카드 이후에는:

1. 트라이의 `개념`을 이해할 수 있어야 한다.
2. 트라이에서 `삽입`, `탐색`을 할 수 있어야 한다.
3. 트라이가 `실제 응용 프로그램`에서 어떻게 도움이 되는지 이해할 수 있다.
4. 트라이를 사용하여 `실제 문제`를 해결할 수 있다.

<br>

## 1. What is Trie?

`트라이`는 `Nary tree`의 특별한 형태이다.
일반적으로, 트라이는 `문자열을 저장`하는데에 사용된다.
각 트라이 노드는 `문자열`(`접두사`)을 표현한다.
각 노드는 여러 개의 자식 노드를 가질 수 있으며 자식 노드로 향하는 경로는 다른 문자를 나타낸다.
그리고 자식 노드가 나타내는 문자열은 노드 자체가 나타내는 원래 문자열에 경로 상의 문자를 더한 것이다. 

아래는 트라이의 예시이다.

<img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/07/screen-shot-2018-01-31-at-163403.png" width="360px">

예시에서, 각 노드에 표시되어 있는 값은 노드가 나타내는 문자열이다.
예를 들어, root 노드에서 시작해서 두번째 경로인 'b'를 고른다. 그 다음은 첫 번째 자식인 'a', 다음은 자식 'd' 를 고른다.
마지막으로 node "bad"에 도착한다.
그 노드의 값은 root노드에서 해당 노드까지 순차적인 경로의 문자들로 형성된다.

`root` 노드는 빈 문자열이라는 것에 주목해야 한다.

트라의 한 가지 중요한 특성은 한 노드의 모든 자손들은 해당 노드와 연관된 문자열의 공통되는 접두사를 가진다는 점이다.
이것이 트라이가 `접두 트리`로 불리는 이유이다.

다시 예시를 보자.
예를 들어, 노드 "b"를 루트로 하는 하위 트리에서 노드들로 표현되는 문자열은 공통된 접두사 "b"를 가지고 있다.
그 역도 마찬가지이다.
공통된 접두사 "b"를 가지고 있는 문자열들은 모두 노드 "b"를 루트로 하는 하위트리 안에 있고,
다른 접두사를 가지는 문자열은 다른 브랜치에서 분리될 것이다. 

트라이는 autocomplete, spell checker 등 다양한 앱에서 널리 사용된다.
이후 챕터에서는 실용적인 응용에 대해서 얘기해볼 것이다.

<br>

## 2. How to represent a Trie?

이전 article에서, Trie에 대한 개념을 소개했다.
이번 article에서는 이 자료 구조를 어떻게 코딩 언어로 표현하는지에 대해 얘기할 것이다.

> 다음 컨텐츠를 읽기 전에 Nary tree의 노드 구조에 대해 간단하게 복습해보면 좋을 것이다.

트라이의 특별한 점은 문자들과 자식 노드들간의 대응하는 관계이다.
트라이 노드는 다양한 다른 표현 방식들이 있다.
여기에 그 중 두 개를 소개한다.

### First Solution - Array

첫 번째 솔루션은 자식 노드들을 저장하기 위해 `배열`을 사용하는 것이다.

예를 들어, 만약 문자 `a`부터 `z`까지만을 포함하는 문자열을 저장한다면,
그의 자식 노드들을 저장하기 위해 각 노드들에 크기가 26인 배열을 선언할 수 있다.
특정 문자 `c`에 있어서, 배열에서 해당하는 자식 노드를 찾기 위해 인덱스로 `c - 'a'`를 사용할 수도 있다.

```java
class TrieNode {
    // change this value to adapt to different cases
    public static final N = 26;
    public TrieNode[] children = new TrieNode[N];
    
    // you might need some extra values according to different cases
};

/** Usage:
 *  Initialization: TrieNode root = new TrieNode();
 *  Return a specific child node with char c: root.children[c - 'a']
 */
```

이 방법의 경우 자식 노드를 방문하는 것은 정말 `빠를` 것이다.
그리고 대부분의 경우에 문자를 인덱스로 쉽게 바꿀 수 있으니 특정한 자식 노드를 방문하는 것도 상대적으로 `쉽다`.
하지만 모든 자식 노드들이 필요한 것은 아니므로 `공간의 낭비`가 있을 수 있다.

### Second Solution - Map

두 번째 솔루션은 자식 노드들을 저장하기 위해 `해시맵`을 사용하는 것이다.

각 노드에서 해시맵을 선언할 수 있다.
해시맵의 키는 문자들이고, 값은 대응하는 자식 노드이다.

```java
class TrieNode {
    public Map<Character, TrieNode> children = new HashMap<>();
    
    // you might need some extra values according to different cases
};

/** Usage:
 *  Initialization: TrieNode root = new TrieNode();
 *  Return a specific child node with char c: root.children.get(c)
 */
```

해당 문자에 대응하는 특정 자식을 직접 방문하는 것은 더 쉽다.
하지만 배열을 사용하는 것보다는 조금 `더 느릴 수 있다`.
그러나, 필요한 자식 노드들만을 저장하기 때문에 `공간을 절약`할 수 있다.
또한 고정되어 있는 길이와 범위로 제한되어 있지 않기 때문에 `더 유연하다`.

### More

트라이 노드에서 자식 노드를 어떻게 표현해야 하는지 언급했다. 또한, 몇몇 다른 값들도 필요할지도 모른다.

예를 들어서, 알다시피, 각 트라이 노드는 문자열을 표현한다.
하지만 트라이 노드들로 표현되는 모든 문자열들이 의미가 있는 것은 아니다.
트라이에 단어들을 저장하기만을 원한다면,
각 노드에 이 노드로 표현되는 문자열이 단어인지 아닌지 나타내는 flag로 boolean을 선언해야 할 지도 모른다.




















