# Summary - Linked List

## Review

간단하게 singly linked list와 doubly linked list의 실행에 대서 복습해보자.

그 둘은 많은 연산에 있어서 비슷하다.

1. 둘 다 `임의의 자리에 있는 데이터에 상수 시간으로 접근할 수 없다`.
2. 둘 다 `리스트의 처음이나 주어진 노드 이후에 새로운 노드를 추가하는 것의 시간 복잡도는 O(1)`이다.
3. 둘 다 `첫 번째 노드를 삭제하는 것의 시간 복잡도는 O(1)`이다.

하지만 (마지막 노드를 포함하여)주어진 노드를 삭제하는 점에서는 약간 다르다.

* singly linked list에서는 주어진 노드의 이전 노드를 얻지 못하기 때문에 주어진 노드를 삭제하기 전에 이전 노드를 알아내기 위해 O(N)의 시간을 소비해야 한다.
* doubly linked list에서는 "prev" 참조 필드로 이전 노드를 얻을 수 있기 때문에 훨씬 쉬워진다. 따라서 주어진 노드를 O(1) 시간으로 삭제할 수 있다.

## Comparison

여기에 linked list와 배열들의 시간 복잡도를 비교한 표가 있다.

|    |           | Array | Singly-Linked List | Doubly-Linked List |
|:--:|:---------:|:-----:|:------------------:|:------------------:|
| 접근 |   인덱스로    | O(1)  |        O(N)        |        O(N)        |
| 추가 | 첫번째 노드 앞에 | O(N)  |        O(1)        |        O(1)        |
| 추가 | 주어진 노드 뒤에 | O(N)  |        O(1)        |        O(1)        |
| 추가 | 마지만 노드 뒤에 | O(1)  |        O(N)        |        O(1)        |
| 삭제 |  첫 번째 노드  | O(N)  |        O(1)        |        O(1)        |
| 삭제 |  주어진 노드   | O(N)  |        O(N)        |        O(1)        |
| 삭제 |  마지막 노드   | O(1)  |        O(N)        |        O(1)        |
| 탐색 |  주어진 노드   | O(N)  |        O(N)        |        O(N)        |

> Note: Doubly-Linked List에서의 시간 복잡도는 Doubly-Linked List의 구현에서 꼬리 노드를 참조한다고 가정한 것이다. 만약 꼬리 노드의 참조가 없다면 마지막 노드 뒤에 노드를
> 추가하는 것이나 마지막 노드를 삭제하는 것 또한 O(N)의 시간이 필요할 것이다.

이 비교 이후, 이 결론을 생각해내는 것은 어렵지 않을 것이다.

> 만약 node를 자주 추가하거나 삭제해야 한다면 linked list는 좋은 선택지가 될 수 있다.
>
> 만약 index로 원소를 자주 탐색해야 한다면, linked list보다 배열이 더 좋은 선택지가 될 것이다.

