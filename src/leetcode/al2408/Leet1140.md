### 1. 문제 설명

이 문제는 Alice와 Bob이 돌 무더기를 차례대로 가져가는 게임입니다.
돌 무더기들은 일렬로 배열되어 있고, 각 무더기에는 양의 정수로 이루어진 돌의 개수 `piles[i]`가 있습니다.
게임의 목표는 최대한 많은 돌을 가져가는 것입니다.

Alice가 먼저 시작하고, 처음에 `M = 1`로 설정됩니다.
각 플레이어는 자기 차례에 남은 무더기들 중에서 첫 `X`개의 무더기를 가져갈 수 있는데, 여기서 `1 <= X <= 2M`입니다.
돌을 가져간 후, `M`의 값은 `M = max(M, X)`로 업데이트됩니다.
이 과정은 모든 돌이 다 사라질 때까지 반복됩니다.

두 플레이어가 모두 최적의 전략으로 게임을 진행할 때, Alice가 최대한 가져갈 수 있는 돌의 개수를 구하는 것이 문제입니다.

### 2. 문제 접근 방식

이 문제는 **다이나믹 프로그래밍(Dynamic Programming)** 기법을 사용하여 해결할 수 있습니다.
게임에서 각 상태를 나타내는 `dp` 배열을 정의하고, 이를 통해 Alice와 Bob의 최적의 선택을 계산합니다.

**접근 방법:**
1. `suffixSum[i]` 배열을 사용하여 `i`번째 무더기부터 끝까지의 돌의 합을 미리 계산해 둡니다.
2. `dp[i][m]`은 `i`번째 무더기부터 시작하여 `M = m`일 때 Alice가 얻을 수 있는 최대 돌의 개수를 나타냅니다.
3. 각 위치 `i`와 `M`에서 Alice가 최적의 선택을 할 수 있도록 가능한 모든 `X` (1부터 2M까지)를 탐색하며 최대값을 계산합니다.
4. 최종적으로 `dp[0][1]`이 Alice가 게임을 시작할 때 얻을 수 있는 최대 돌의 개수입니다.

### 3. 코드

```java
public int stoneGameII(int[] piles) {
    int n = piles.length;
    
    // dp[i][m]은 i번째 돌부터 시작하고 M이 m일 때, 현재 플레이어가 가져갈 수 있는 최대 돌의 개수
    int[][] dp = new int[n][n + 1];
    
    // suffixSum[i]는 i번째 돌부터 끝까지 남은 돌의 총합을 나타냄
    int[] suffixSum = new int[n];
    suffixSum[n - 1] = piles[n - 1];
    
    // 뒤에서부터 순서대로 suffixSum을 채움
    for (int i = n - 2; i >= 0; i--) {
        suffixSum[i] = suffixSum[i + 1] + piles[i];
    }
    
    // 뒤에서부터 돌 무더기와 M에 대해 최적의 결과 계산
    for (int i = n - 1; i >= 0; i--) {
        for (int m = 1; m <= n; m++) {
            // 만약 i번째 돌에서 남은 돌의 수가 현재 M으로 가져갈 수 있는 최대 돌의 수보다 적으면
            if (i + 2 * m >= n) {
                // 남은 모든 돌을 가져감
                dp[i][m] = suffixSum[i];
            } else {
                // 가져갈 수 있는 돌의 수를 1부터 2M까지 시도하며 최적의 선택 계산
                for (int x = 1; x <= 2 * m; x++) {
                    // 현재 가져갈 수 있는 돌의 수를 빼고 상대방이 가져갈 수 있는 돌의 개수를 뺀 후 최댓값 선택
                    dp[i][m] = Math.max(dp[i][m], suffixSum[i] - dp[i + x][Math.max(m, x)]);
                }
            }
        }
    }
    
    // 게임의 시작점에서 Alice가 최대한 가져갈 수 있는 돌의 개수 반환
    return dp[0][1];
}
```

### 주석을 통해 코드 이해하기

1. **dp 배열 초기화 (`dp[i][m]`)**:
    - `dp[i][m]`는 현재 `i`번째 돌부터 시작하고 `M`이 `m`일 때, 현재 플레이어가 가져갈 수 있는 최대 돌의 개수를 의미합니다. 이 배열을 통해 각각의 상태에서 최적의 돌 개수를 계산합니다.

2. **suffixSum 배열 초기화**:
    - `suffixSum[i]`는 `i`번째 돌부터 끝까지 남은 돌의 총합을 나타냅니다. 이를 통해 특정 시점에서 남은 돌의 총 개수를 쉽게 계산할 수 있습니다.

3. **suffixSum 배열 채우기**:
    - `suffixSum` 배열을 뒤에서부터 채워 나갑니다. 예를 들어, `suffixSum[3] = piles[3] + piles[4] + ... + piles[n-1]`와 같이 계산됩니다.

4. **다이나믹 프로그래밍을 통한 최적의 결과 계산**:
    - `i`부터 시작하여 모든 `M`의 값에 대해 최적의 돌 개수를 계산합니다.
    - 만약 남은 돌의 수가 현재 `M`으로 가져갈 수 있는 최대 돌의 수보다 적다면, 남은 돌을 모두 가져갑니다.
    - 그렇지 않으면, 가능한 모든 `X` 값을 시도하며 최적의 결과를 계산합니다.

5. **최종 결과 반환**:
    - `dp[0][1]`은 게임의 시작점에서 Alice가 가져갈 수 있는 최대 돌의 개수를 반환합니다.
