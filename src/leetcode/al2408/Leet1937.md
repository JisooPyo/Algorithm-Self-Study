### 문제의 핵심

이 문제의 목표는 주어진 행렬에서 각 행에서 하나의 셀을 선택해 최대한 많은 포인트를 얻는 것입니다.
단, 선택한 셀 간의 거리에 따라 페널티가 적용됩니다. 이 거리 페널티는 두 셀의 열 인덱스 차이(`abs(c1 - c2)`)로 계산됩니다.

### 기본 접근법과 문제점

처음 제시된 풀이는 각 셀을 선택할 때 이전 행의 모든 셀과 비교해서 최적의 값을 찾는 방식이었습니다.
이 방법은 `O(m * n²)`의 시간 복잡도를 가집니다. 여기서 `m`은 행의 수, `n`은 열의 수입니다.
모든 셀을 비교하므로 계산이 많아져 비효율적입니다.

### 최적화 아이디어

**문제:** 페널티 계산(`abs(c1 - c2)`) 때문에 모든 셀을 비교해야 한다.

**해결책:** 각 행에서 이전 행의 최적의 셀을 빠르게 찾는 방법이 있다면, 모든 셀을 비교하지 않고도 최적의 값을 계산할 수 있습니다.

### 최적화 풀이

1. **leftMax와 rightMax를 사용한 접근법**:
    - `leftMax[j]`: 현재 행에서 `j` 열까지 왼쪽에서 오는 경우, 이전 행에서 최적의 값이 될 수 있는 값을 미리 계산해 둡니다.
    - `rightMax[j]`: 현재 행에서 `j` 열까지 오른쪽에서 오는 경우, 이전 행에서 최적의 값이 될 수 있는 값을 미리 계산해 둡니다.

2. **leftMax 계산**:
    - 왼쪽에서 오른쪽으로 순회하면서, 이전 행의 `dp[j]`에 `j` 인덱스를 더해 누적된 최대값을 계산합니다. 이 값은 `dp[j] + j`가 됩니다.
    - 이 값을 활용해 현재 행의 각 열에서 최적의 왼쪽 경로를 빠르게 찾습니다.

3. **rightMax 계산**:
    - 오른쪽에서 왼쪽으로 순회하면서, 이전 행의 `dp[j]`에 `j` 인덱스를 빼서 누적된 최대값을 계산합니다. 이 값은 `dp[j] - j`가 됩니다.
    - 이 값을 활용해 현재 행의 각 열에서 최적의 오른쪽 경로를 빠르게 찾습니다.

4. **dp 업데이트**:
    - 각 셀에서 `leftMax[j] - j`와 `rightMax[j] + j`를 비교해 최적의 값을 선택합니다.

### 쉽게 이해하기

한마디로, 이 방법은 모든 셀을 일일이 비교하지 않고,
**각 행에서 왼쪽과 오른쪽으로부터 최적의 경로를 미리 계산**하여 다음 행의 값을 빠르게 갱신하는 것입니다.
이렇게 함으로써 시간 복잡도를 크게 줄일 수 있습니다.

이 접근법은 **동적 프로그래밍**(DP)의 대표적인 최적화 기법인 **배열을 통한 누적 최대값 계산**을 사용한 것입니다.
이를 통해 필요한 비교 횟수를 줄여 문제를 훨씬 더 효율적으로 해결할 수 있습니다.
